<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Severe Weather Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { display: flex; flex-direction: column; height: 100vh; background-color: #f0f2f5; }
        header { background: linear-gradient(to right, #2c3e50, #4a6491); color: white; padding: 1rem; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 10px rgba(0,0,0,0.2);}
        .logo { display: flex; align-items: center; gap: 0.5rem; }
        .logo i { font-size: 1.8rem; }
        .address-form { display: flex; gap: 0.5rem; }
        .address-input { padding: 0.5rem; border: none; border-radius: 4px; width: 250px; }
        button { background-color: #3498db; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; }
        button:hover { background-color: #2980b9; }
        .alert-banner { background-color: #e74c3c; color: white; padding: 0.8rem; text-align: center; display: none; box-shadow: 0 2px 5px rgba(0,0,0,0.2); position: relative; z-index: 1000; }
        .alert-banner.active { display: block; animation: pulse 2s infinite; }
        @keyframes pulse { 0% {opacity:1;} 50% {opacity:0.8;} 100% {opacity:1;} }
        .map-container { flex: 1; position: relative; }
        #map { height: 100%; width: 100%; background: #e8e8e8; }
        .info-panel { position: absolute; top: 1rem; right: 1rem; background-color: white; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000; max-width: 300px; display: none; }
        .info-panel h3 { margin-bottom: 0.5rem; color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 0.5rem; }
        .info-panel p { margin: 0.3rem 0; color: #34495e; }
        .legend { position: absolute; bottom: 1rem; right: 1rem; background-color: white; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000; max-height: 300px; overflow-y: auto; }
        .legend h3 { margin-bottom: 0.5rem; color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 0.5rem; }
        .legend-item { display: flex; align-items: center; margin: 0.3rem 0; }
        .legend-color { width: 20px; height: 20px; margin-right: 0.5rem; border-radius: 3px; border: 1px solid #888; }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(255,255,255,0.9); padding: 1rem 2rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000; display: none; }
        .refresh-info { position: absolute; bottom: 1rem; left: 1rem; background-color: rgba(255,255,255,0.8); padding: 0.5rem 1rem; border-radius: 8px; font-size: 0.9rem; z-index: 1000; }
        .filter-panel { position: absolute; top: 1rem; left: 1rem; background-color: white; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000; max-width: 200px; }
        .filter-panel h3 { margin-bottom: 0.5rem; color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 0.5rem; }
        .filter-checkbox { margin: 0.3rem 0; }
        .progress-bar { position: absolute; bottom: 3.5rem; left: 1rem; width: 200px; height: 10px; background-color: #f0f0f0; border-radius: 5px; overflow: hidden; z-index: 1000; }
        .progress { height: 100%; background-color: #3498db; width: 0%; transition: width 0.3s; }
        .api-status { position: absolute; bottom: 5rem; left: 1rem; background-color: rgba(255,255,255,0.8); padding: 0.5rem 1rem; border-radius: 8px; font-size: 0.8rem; z-index: 1000; }
        .view-toggle { position: absolute; top: 1rem; left: 16.5rem; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.15); z-index: 1001; padding: 0.5rem 1rem; display: flex; align-items: center; gap: 0.5rem; }
        .view-toggle label { font-weight: 500; color: #2c3e50; }
        .view-toggle select { padding: 0.2rem 0.6rem; border-radius: 4px; border: 1px solid #ccc; }
        .county-outline { color: #222; weight: 1.5; fill: #fff; fillOpacity: 0; opacity: 0.7; pointer-events: none; }
        .inactive-county { fill: #fff; fill-opacity: 0.7; opacity: 0.6; pointer-events: none; }
        .active-county { fill-opacity: 0.7; opacity: 1; pointer-events: auto; }
        .marine-zone-outline { color: #11b6e8; weight: 1.3; fill: #b6f1ff; fill-opacity: 0.18; opacity: 0.8; pointer-events: none; }
    </style>
</head>
<body>
    <header>
        <div class="logo">
            <i>üå™Ô∏è</i>
            <h1>Severe Weather Tracker</h1>
        </div>
        <div class="address-form">
            <input type="text" class="address-input" placeholder="Enter your address" id="address-input">
            <button id="save-address">Save Location</button>
        </div>
    </header>
    <div class="alert-banner" id="alert-banner"></div>
    <div class="map-container">
        <div id="map"></div>
        <div class="info-panel" id="info-panel"></div>
        <div class="filter-panel">
            <h3>Filter Alerts</h3>
            <div id="alert-filters"></div>
        </div>
        <div class="view-toggle">
            <label for="view-mode">View Mode:</label>
            <select id="view-mode">
                <option value="polygon" selected>Polygon</option>
                <option value="county">Active County</option>
            </select>
        </div>
        <div class="legend">
            <h3>Legend</h3>
            <div id="legend-items"></div>
        </div>
        <div class="refresh-info">
            Data refreshes every minute. Last updated: <span id="last-updated">-</span>
        </div>
        <div class="progress-bar">
            <div class="progress" id="progress-bar"></div>
        </div>
        <div class="api-status" id="api-status">
            Geoapify requests today: <span id="geoapify-count">0</span>/3000
        </div>
        <div class="loading" id="loading">
            Loading weather data...
        </div>
    </div>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <script>
        const map = L.map('map', { zoomSnap: 0.1, preferCanvas: true }).setView([39.8283, -98.5795], 4);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        let alertLayers = {};
        let userMarker = null;
        let userLocation = null;
        let alertTypes = {};
        let countyGeojson = null;
        let countyFeatureCollection = null;
        let cwaGeojson = null;
        let cwaFeatureCollection = null;
        let marineZonesGeojson = null;
        let marineZonesFeatureCollection = null;
        let geoapifyRequestCount = 0;
        let allAlerts = [];
        let polygonMode = true;
        let countyOutlinesLayer = null;
        let marineZonesLayer = null;
        let cwaLayer = null;
        let countyActiveLayer = null;
        let cityPointsLayer = null;
        let alertPolygonLayer = null;
        let affectedZoneLayer = null;

        const alertStyles = {
            "Tornado Warning": { color: "#ff0000", className: "pulsing-layer", severityRank: 1 },
            "Tornado Watch": { color: "#ffcc00", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 2 },
            "Tornado Emergency": { color: "#cc00ff", className: "pulsing-layer", severityRank: 0 },
            "Flash Flood Warning": { color: "#880000", className: "pulsing-layer", severityRank: 2 },
            "Flood Advisory": { color: "#ffff00", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 5 },
            "Flood Watch": { color: "#aaff00", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 4 },
            "Flood Warning": { color: "#007700", className: "pulsing-layer", severityRank: 2 },
            "Coastal Flood Advisory": { color: "#77aaff", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 5 },
            "Coastal Flood Warning": { color: "#0055ff", className: "pulsing-layer", severityRank: 2 },
            "Coastal Flood Statement": { color: "#aaccff", dashArray: "5, 5", fillOpacity: 0.2, severityRank: 6 },
            "Severe Thunderstorm Warning": { color: "#ff0000", dashArray: "10, 10", className: "pulsing-layer", severityRank: 2 },
            "Severe Thunderstorm Watch": { color: "#ffcc00", fillOpacity: 0.3, severityRank: 3 },
            "Special Weather Statement": { color: "#cccccc", dashArray: "5, 5", fillOpacity: 0.2, severityRank: 7 },
            "Winter Storm Warning": { color: "#00aaff", className: "pulsing-layer", severityRank: 2 },
            "Winter Storm Watch": { color: "#00ccff", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 3 },
            "Winter Weather Advisory": { color: "#00ffff", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 4 },
            "Blizzard Warning": { color: "#ffffff", className: "pulsing-layer", severityRank: 1 },
            "Wind Advisory": { color: "#ffaa00", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 5 },
            "High Wind Warning": { color: "#ff7700", className: "pulsing-layer", severityRank: 2 },
            "Gale Warning": { color: "#0077ff", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 3 },
            "Gale Watch": { color: "#0055cc", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 4 },
            "Small Craft Advisory": { color: "#5555ff", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 6 },
            "Marine Weather Statement": { color: "#aaaaff", dashArray: "5, 5", fillOpacity: 0.2, severityRank: 8 },
            "Tropical Storm Warning": { color: "#00ddcc", className: "pulsing-layer", severityRank: 1 },
            "Tropical Storm Watch": { color: "#00ffee", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 3 },
            "Hurricane Warning": { color: "#ff0000", className: "pulsing-layer", severityRank: 0 },
            "Hurricane Watch": { color: "#ff8888", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 2 },
            "Heat Advisory": { color: "#ff5500", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 3 },
            "Excessive Heat Warning": { color: "#ff0000", className: "pulsing-layer", severityRank: 1 },
            "Dense Fog Advisory": { color: "#aaaaaa", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 6 },
            "Dense Smoke Advisory": { color: "#666666", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 6 },
            "Air Quality Alert": { color: "#aa66aa", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 7 },
            "Rip Current Statement": { color: "#00ccff", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 8 },
            "Beach Hazards Statement": { color: "#00aacc", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 8 },
            "Lake Wind Advisory": { color: "#55aaff", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 6 },
            "Frost Advisory": { color: "#ccffff", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 5 },
            "Freeze Warning": { color: "#00ffff", className: "pulsing-layer", severityRank: 2 },
            "Freeze Watch": { color: "#00cccc", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 4 },
            "Ashfall Advisory": { color: "#888888", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 6 },
            "Dust Storm Warning": { color: "#ccaa00", className: "pulsing-layer", severityRank: 1 },
            "Dust Storm Advisory": { color: "#ccbb77", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 5 },
            "Snow Squall Warning": { color: "#ffffff", className: "pulsing-layer", severityRank: 1 },
            "Extreme Wind Warning": { color: "#ff00ff", className: "pulsing-layer", severityRank: 0 },
            "Special Marine Warning": { color: "#ff5555", className: "pulsing-layer", severityRank: 1 },
            "_default": { color: "#5555ff", fillOpacity: 0.3, severityRank: 99 }
        };

        let marineZoneLookup = {};
        let cwaLookup = {};
        let countyLookup = {};

        const STATE_ABBRS = [
            "AL","AK","AZ","AR","CA","CO","CT","DE","FL","GA","HI","ID","IL","IN","IA","KS","KY","LA","ME","MD",
            "MA","MI","MN","MS","MO","MT","NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK","OR","PA","RI","SC",
            "SD","TN","TX","UT","VT","VA","WA","WV","WI","WY","DC","PR","VI","GU","AS","MP"
        ];

        function getAlertStyle(properties) {
            const eventType = properties.event;
            const styleConfig = alertStyles[eventType] || alertStyles["_default"];
            return {
                color: styleConfig.color,
                weight: 3,
                opacity: 1,
                fillColor: styleConfig.color,
                fillOpacity: styleConfig.fillOpacity || 0.3,
                dashArray: styleConfig.dashArray,
                className: styleConfig.className,
                severityRank: styleConfig.severityRank !== undefined ? styleConfig.severityRank : 99
            };
        }

        document.addEventListener("DOMContentLoaded", function() {
            const savedAddress = localStorage.getItem("weatherTrackerAddress");
            if (savedAddress) {
                document.getElementById("address-input").value = savedAddress;
                geocodeAddress(savedAddress);
            }
            document.getElementById("save-address").addEventListener("click", saveAddress);
            const savedCount = localStorage.getItem("geoapifyRequestCount");
            if (savedCount) {
                geoapifyRequestCount = parseInt(savedCount);
                document.getElementById("geoapify-count").textContent = geoapifyRequestCount;
            }

            const savedViewMode = localStorage.getItem("weatherTrackerViewMode");
            if (savedViewMode) {
                document.getElementById("view-mode").value = savedViewMode;
                polygonMode = savedViewMode === "polygon";
            }

            document.getElementById("view-mode").addEventListener("change", function() {
                polygonMode = this.value === "polygon";
                localStorage.setItem("weatherTrackerViewMode", this.value);
                renderAlerts();
            });

            Promise.all([
                loadAllCountyBoundaries(),
                loadMarineZones(),
                loadCWABoundaries()
            ]).then(() => fetchWeatherData());
            setInterval(fetchWeatherData, 60000);
        });

        async function loadAllCountyBoundaries() {
            countyLookup = {};
            let features = [];
            let fetchCount = 0;
            for (let abbr of STATE_ABBRS) {
                try {
                    const url = `https://raw.githubusercontent.com/Bella288/svr-wx-data/main/counties_${abbr}.geojson`;
                    const response = await fetch(url);
                    if (response.ok) {
                        const geojson = await response.json();
                        if (geojson.features && Array.isArray(geojson.features)) {
                            for (const feature of geojson.features) {
                                let fips = "";
                                if (feature.properties) {
                                    if (feature.properties.GEOID) {
                                        fips = feature.properties.GEOID;
                                    } else if (feature.properties.FIPS) {
                                        fips = feature.properties.FIPS;
                                    }
                                    if (fips) countyLookup[fips] = feature;
                                }
                                features.push(feature);
                            }
                        }
                        fetchCount++;
                        document.getElementById("progress-bar").style.width = `${Math.round((fetchCount / STATE_ABBRS.length) * 100)}%`;
                    }
                } catch (error) {}
            }
            countyFeatureCollection = { type: "FeatureCollection", features };
        }

        async function loadMarineZones() {
            try {
                const url = "https://raw.githubusercontent.com/Bella288/svr-wx-data/main/marine_zones_us.geojson";
                const resp = await fetch(url);
                marineZonesGeojson = await resp.json();
                marineZonesFeatureCollection = marineZonesGeojson;
                marineZoneLookup = {};
                if (marineZonesFeatureCollection && marineZonesFeatureCollection.features) {
                    marineZonesFeatureCollection.features.forEach(f => {
                        if (f.properties && f.properties.ZONE) {
                            marineZoneLookup[f.properties.ZONE] = f;
                        }
                    });
                }
            } catch (error) {
                marineZonesGeojson = { type: "FeatureCollection", features: [] };
                marineZoneLookup = {};
            }
        }

        async function loadCWABoundaries() {
            try {
                const url = "https://raw.githubusercontent.com/Bella288/svr-wx-data/main/nws_cwa.geojson";
                const resp = await fetch(url);
                cwaGeojson = await resp.json();
                cwaFeatureCollection = cwaGeojson;
                cwaLookup = {};
                if (cwaFeatureCollection && cwaFeatureCollection.features) {
                    cwaFeatureCollection.features.forEach(f => {
                        if (f.properties && f.properties.CWA) {
                            cwaLookup[f.properties.CWA] = f;
                        }
                    });
                }
            } catch (error) {
                cwaGeojson = { type: "FeatureCollection", features: [] };
                cwaLookup = {};
            }
        }

        function saveAddress() {
            const address = document.getElementById("address-input").value;
            if (address.trim() !== "") {
                localStorage.setItem("weatherTrackerAddress", address);
                geocodeAddress(address);
            }
        }

        function geocodeAddress(address) {
            document.getElementById("loading").style.display = "block";
            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`)
                .then(response => response.json())
                .then(data => {
                    if (data && data.length > 0) {
                        const lat = parseFloat(data[0].lat);
                        const lon = parseFloat(data[0].lon);
                        userLocation = { lat, lng: lon };
                        map.setView([lat, lon], 9);
                        if (userMarker) map.removeLayer(userMarker);
                        userMarker = L.marker([lat, lon]).addTo(map).bindPopup("Your location").openPopup();
                        checkUserInAlertArea();
                    } else {
                        alert("Address not found. Please try a more specific address.");
                    }
                })
                .catch(error => {
                    alert("Error finding address. Please try again.");
                })
                .finally(() => {
                    document.getElementById("loading").style.display = "none";
                });
        }

        async function fetchZoneGeometry(url) {
            try {
                let resp = await fetch(url);
                if (!resp.ok) return null;
                let data = await resp.json();
                if (data.geometry && (data.geometry.type === "Polygon" || data.geometry.type === "MultiPolygon")) {
                    return data.geometry;
                }
            } catch (e) {}
            return null;
        }

        function fetchWeatherData() {
            document.getElementById("loading").style.display = "block";
            Object.keys(alertLayers).forEach(id => {
                try { map.removeLayer(alertLayers[id]); } catch {}
            });
            if (countyActiveLayer) {
                countyActiveLayer.clearLayers();
                map.removeLayer(countyActiveLayer);
                countyActiveLayer = null;
            }
            if (countyOutlinesLayer) {
                countyOutlinesLayer.clearLayers();
                map.removeLayer(countyOutlinesLayer);
                countyOutlinesLayer = null;
            }
            if (cityPointsLayer) { cityPointsLayer.clearLayers(); map.removeLayer(cityPointsLayer); cityPointsLayer = null; }
            if (alertPolygonLayer) { alertPolygonLayer.clearLayers(); map.removeLayer(alertPolygonLayer); alertPolygonLayer = null; }
            if (affectedZoneLayer) { affectedZoneLayer.clearLayers(); map.removeLayer(affectedZoneLayer); affectedZoneLayer = null; }
            alertLayers = {};
            alertTypes = {};
            allAlerts = [];
            document.getElementById("progress-bar").style.width = "0%";
            fetch("https://api.weather.gov/alerts/active")
                .then(r => r.json())
                .then(data => {
                    allAlerts = (data.features || []);
                    if (!allAlerts.length) {
                        document.getElementById("loading").style.display = "none";
                        return;
                    }
                    renderAlerts();
                    document.getElementById("last-updated").textContent = new Date().toLocaleTimeString();
                    document.getElementById("progress-bar").style.width = "100%";
                    document.getElementById("loading").style.display = "none";
                })
                .catch(e => {
                    document.getElementById("loading").style.display = "none";
                });
        }

        function renderAlerts() {
            Object.keys(alertLayers).forEach(id => {
                try { map.removeLayer(alertLayers[id]); } catch {}
            });
            alertLayers = {};
            alertTypes = {};
            if (countyActiveLayer) {
                countyActiveLayer.clearLayers();
                map.removeLayer(countyActiveLayer);
                countyActiveLayer = null;
            }
            if (countyOutlinesLayer) {
                countyOutlinesLayer.clearLayers();
                map.removeLayer(countyOutlinesLayer);
                countyOutlinesLayer = null;
            }
            if (cityPointsLayer) { cityPointsLayer.clearLayers(); map.removeLayer(cityPointsLayer); cityPointsLayer = null; }
            if (alertPolygonLayer) { alertPolygonLayer.clearLayers(); map.removeLayer(alertPolygonLayer); alertPolygonLayer = null; }
            if (affectedZoneLayer) { affectedZoneLayer.clearLayers(); map.removeLayer(affectedZoneLayer); affectedZoneLayer = null; }
            allAlerts.forEach(alert => {
                const event = alert.properties.event;
                alertTypes[event] = true;
            });
            updateFiltersAndLegend();
            if (polygonMode) {
                allAlerts.forEach(alert => {
                    processAlertForView(alert, true);
                });
            } else {
                renderActiveCountyView();
            }
            if (userLocation) checkUserInAlertArea();
        }

        function processAlertForView(alert, polygonMode = true) {
            const properties = alert.properties;
            const geometry = alert.geometry;
            const eventType = properties.event;
            const style = getAlertStyle(properties);
            let layer = null;
            let show = true;
            const filterCheckbox = document.getElementById("filter-" + eventType.replace(/\s+/g, "-"));
            if (filterCheckbox && !filterCheckbox.checked) show = false;
            if (polygonMode) {
                if (geometry && (geometry.type === "Polygon" || geometry.type === "MultiPolygon")) {
                    if (geometry.type === "Polygon") {
                        const coordinates = geometry.coordinates[0];
                        const latLngs = coordinates.map(coord => [coord[1], coord[0]]);
                        layer = L.polygon(latLngs, style)
                                .bindPopup(createPopupContent(properties));
                    } else if (geometry.type === "MultiPolygon") {
                        const polygons = geometry.coordinates.map(polygonCoords => {
                            const latLngs = polygonCoords[0].map(coord => [coord[1], coord[0]]);
                            return L.polygon(latLngs, style);
                        });
                        layer = L.featureGroup(polygons).bindPopup(createPopupContent(properties));
                    }
                } else {
                    let polygons = [];
                    if (properties.geocode && properties.geocode.UGC && countyLookup && countyFeatureCollection) {
                        properties.geocode.UGC.forEach(ugcCode => {
                            if (ugcCode.length === 6) {
                                const stateCode = ugcCode.substring(0, 2);
                                const countyCode = ugcCode.substring(2);
                                const fipsCode = stateCode + countyCode;
                                const countyGeometry = countyLookup[fipsCode];
                                if (countyGeometry) {
                                    const countyLayer = L.geoJSON(countyGeometry, {
                                        style: style,
                                        onEachFeature: function(feature, layer) {
                                            layer.bindPopup(createPopupContent(properties));
                                        }
                                    });
                                    polygons.push(countyLayer);
                                }
                            }
                        });
                    }
                    if (properties.geocode && properties.geocode.FIPS && countyFeatureCollection) {
                        properties.geocode.FIPS.forEach(fipsCode => {
                            const countyGeometry = countyLookup[fipsCode];
                            if (countyGeometry) {
                                const countyLayer = L.geoJSON(countyGeometry, {
                                    style: style,
                                    onEachFeature: function(feature, layer) {
                                        layer.bindPopup(createPopupContent(properties));
                                    }
                                });
                                polygons.push(countyLayer);
                            }
                        });
                    }
                    if (properties.geocode && properties.geocode.MARINE && marineZoneLookup && marineZonesFeatureCollection) {
                        properties.geocode.MARINE.forEach(zoneCode => {
                            const marineFeat = marineZoneLookup[zoneCode];
                            if (marineFeat) {
                                const marineLayer = L.geoJSON(marineFeat, {
                                    style: {
                                        color: "#11b6e8",
                                        weight: 2,
                                        fillColor: "#b6f1ff",
                                        fillOpacity: 0.18,
                                        opacity: 0.8,
                                        className: "marine-zone-outline"
                                    },
                                    onEachFeature: function(feature, l) {
                                        l.bindPopup(createPopupContent(properties));
                                    }
                                });
                                polygons.push(marineLayer);
                            }
                        });
                    }
                    if (properties.geocode && properties.geocode.CWA && cwaLookup && cwaFeatureCollection) {
                        properties.geocode.CWA.forEach(cwaCode => {
                            const cwaFeat = cwaLookup[cwaCode];
                            if (cwaFeat) {
                                const cwaLayer = L.geoJSON(cwaFeat, {
                                    style: {
                                        color: "#222",
                                        weight: 2,
                                        fillColor: style.color,
                                        fillOpacity: 0.22,
                                        opacity: 0.6,
                                        className: "cwa-outline"
                                    },
                                    onEachFeature: function(feature, l) {
                                        l.bindPopup(createPopupContent(properties));
                                    }
                                });
                                polygons.push(cwaLayer);
                            }
                        });
                    }
                    if (polygons.length > 0) {
                        layer = L.featureGroup(polygons);
                    }
                }
            }
            if (layer && show) {
                addLayerEventListeners(layer, properties);
                alertLayers[properties.id] = layer;
                layer.addTo(map);
            }
        }

        function renderActiveCountyView() {
            if (!countyFeatureCollection) return;
            countyOutlinesLayer = L.geoJSON(countyFeatureCollection, {
                style: function() {
                    return {
                        color: "#888",
                        weight: 1,
                        fillColor: "#fff",
                        fillOpacity: 0,
                        className: "county-outline"
                    };
                }
            }).addTo(map);

            let countyAlertsByFIPS = {};
            let alertGeometries = [];
            let cityPoints = [];
            let affectedZoneGeometriesPromises = [];
            let affectedZoneProps = [];

            allAlerts.forEach(alert => {
                const properties = alert.properties;
                const eventType = properties.event;
                const style = getAlertStyle(properties);
                let show = true;
                const filterCheckbox = document.getElementById("filter-" + eventType.replace(/\s+/g, "-"));
                if (filterCheckbox && !filterCheckbox.checked) show = false;
                if (!show) return;

                if (alert.geometry && (alert.geometry.type === "Polygon" || alert.geometry.type === "MultiPolygon")) {
                    alertGeometries.push({
                        geometry: alert.geometry,
                        style: style,
                        properties: properties
                    });
                }
                if ((!alert.geometry || !alert.geometry.coordinates) && Array.isArray(properties.affectedZones) && properties.affectedZones.length > 0) {
                    properties.affectedZones.forEach(zoneUrl => {
                        affectedZoneProps.push({style: style, properties: properties});
                        affectedZoneGeometriesPromises.push(fetchZoneGeometry(zoneUrl));
                    });
                }
                let mentionCity = false;
                let cityName = null;
                if (properties.areaDesc && /city/i.test(properties.areaDesc)) {
                    const match = properties.areaDesc.match(/([A-Za-z ]+ City)/i);
                    if (match) {
                        mentionCity = true;
                        cityName = match[1];
                    }
                }
                if (!mentionCity && properties.headline && /city/i.test(properties.headline)) {
                    const match2 = properties.headline.match(/([A-Za-z ]+ City)/i);
                    if (match2) {
                        mentionCity = true;
                        cityName = match2[1];
                    }
                }
                if (mentionCity && cityName) {
                    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(cityName)}&countrycodes=us&limit=1`)
                        .then(response => response.json())
                        .then(data => {
                            if (data && data.length > 0) {
                                cityPoints.push({
                                    lat: parseFloat(data[0].lat),
                                    lng: parseFloat(data[0].lon),
                                    properties: properties
                                });
                                addCityPointsLayer(cityPoints);
                            }
                        });
                }
                if (properties.geocode && properties.geocode.UGC && countyLookup) {
                    properties.geocode.UGC.forEach(ugcCode => {
                        if (ugcCode.length === 6) {
                            const stateCode = ugcCode.substring(0, 2);
                            const countyCode = ugcCode.substring(2);
                            const fipsCode = stateCode + countyCode;
                            if (!countyAlertsByFIPS[fipsCode]) countyAlertsByFIPS[fipsCode] = [];
                            countyAlertsByFIPS[fipsCode].push({
                                alert,
                                style
                            });
                        }
                    });
                }
                if (properties.geocode && properties.geocode.FIPS && countyLookup) {
                    properties.geocode.FIPS.forEach(fipsCode => {
                        if (!countyAlertsByFIPS[fipsCode]) countyAlertsByFIPS[fipsCode] = [];
                        countyAlertsByFIPS[fipsCode].push({
                            alert,
                            style
                        });
                    });
                }
            });

            if (alertGeometries.length > 0) {
                alertPolygonLayer = L.layerGroup();
                alertGeometries.forEach(item => {
                    let layer;
                    if (item.geometry.type === "Polygon") {
                        const coordinates = item.geometry.coordinates[0];
                        const latLngs = coordinates.map(coord => [coord[1], coord[0]]);
                        layer = L.polygon(latLngs, item.style)
                            .bindPopup(createCountyPopupContent(item.properties))
                            .on("mouseover", function(e) {
                                showSimpleInfoPanel(item.properties, e.latlng);
                            })
                            .on("mouseout", function() {
                                hideInfoPanel();
                            });
                    } else if (item.geometry.type === "MultiPolygon") {
                        const polygons = item.geometry.coordinates.map(polygonCoords => {
                            const latLngs = polygonCoords[0].map(coord => [coord[1], coord[0]]);
                            return L.polygon(latLngs, item.style)
                                .on("mouseover", function(e) {
                                    showSimpleInfoPanel(item.properties, e.latlng);
                                })
                                .on("mouseout", function() {
                                    hideInfoPanel();
                                });
                        });
                        layer = L.featureGroup(polygons).bindPopup(createCountyPopupContent(item.properties));
                    }
                    if (layer) { alertPolygonLayer.addLayer(layer); }
                });
                alertPolygonLayer.addTo(map);
            }

            if (affectedZoneGeometriesPromises.length > 0) {
                Promise.all(affectedZoneGeometriesPromises).then(geoms => {
                    affectedZoneLayer = L.layerGroup();
                    geoms.forEach((geometry, i) => {
                        if (!geometry) return;
                        const style = affectedZoneProps[i].style;
                        const properties = affectedZoneProps[i].properties;
                        let layer = null;
                        if (geometry.type === "Polygon") {
                            const coordinates = geometry.coordinates[0];
                            const latLngs = coordinates.map(coord => [coord[1], coord[0]]);
                            layer = L.polygon(latLngs, style).bindPopup(createCountyPopupContent(properties))
                                .on("mouseover", function(e) {
                                    showSimpleInfoPanel(properties, e.latlng);
                                })
                                .on("mouseout", function() {
                                    hideInfoPanel();
                                });
                        } else if (geometry.type === "MultiPolygon") {
                            const polygons = geometry.coordinates.map(polygonCoords => {
                                const latLngs = polygonCoords[0].map(coord => [coord[1], coord[0]]);
                                return L.polygon(latLngs, style)
                                    .on("mouseover", function(e) {
                                        showSimpleInfoPanel(properties, e.latlng);
                                    })
                                    .on("mouseout", function() {
                                        hideInfoPanel();
                                    });
                            });
                            layer = L.featureGroup(polygons).bindPopup(createCountyPopupContent(properties));
                        }
                        if (layer) { affectedZoneLayer.addLayer(layer); }
                    });
                    affectedZoneLayer.addTo(map);
                });
            }

            const countyAlertFeatures = [];
            for (const fips in countyAlertsByFIPS) {
                const base = countyLookup[fips];
                if (base) {
                    let highestSeverityIdx = 99;
                    let mostSevereAlertObj = null;
                    for (const alertObj of countyAlertsByFIPS[fips]) {
                        const sRank = alertObj.style.severityRank !== undefined ? alertObj.style.severityRank : 99;
                        if (sRank < highestSeverityIdx) {
                            highestSeverityIdx = sRank;
                            mostSevereAlertObj = alertObj;
                        }
                    }
                    if (mostSevereAlertObj) {
                        const feature = JSON.parse(JSON.stringify(base));
                        feature.properties = feature.properties || {};
                        feature.properties._alert = mostSevereAlertObj.alert;
                        feature.properties._alertStyle = mostSevereAlertObj.style;
                        countyAlertFeatures.push(feature);
                    }
                }
            }
            if (countyAlertFeatures.length > 0) {
                countyActiveLayer = L.geoJSON(
                    { type: "FeatureCollection", features: countyAlertFeatures },
                    {
                        style: function(f) {
                            const s = f.properties._alertStyle || {};
                            return {
                                color: "#222",
                                weight: 2,
                                fillColor: s.color || "#fff",
                                fillOpacity: (s.fillOpacity !== undefined ? s.fillOpacity : 0.7),
                                className: "active-county " + (s.className || ""),
                                dashArray: s.dashArray || null
                            };
                        },
                        onEachFeature: function(feature, layer) {
                            if (feature.properties && feature.properties._alert) {
                                layer.bindPopup(createCountyPopupContent(feature.properties._alert.properties));
                                layer.on("mouseover", function(e) {
                                    showSimpleInfoPanel(feature.properties._alert.properties, e.latlng);
                                });
                                layer.on("mouseout", function() {
                                    hideInfoPanel();
                                });
                                addLayerEventListeners(layer, feature.properties._alert.properties);
                            }
                        }
                    }
                ).addTo(map);
            }

            addCityPointsLayer(cityPoints);

            if (marineZonesFeatureCollection && marineZonesFeatureCollection.features.length > 0) {
                marineZonesLayer = L.geoJSON(marineZonesFeatureCollection, {
                    style: {
                        color: "#11b6e8",
                        weight: 1,
                        fillColor: "#b6f1ff",
                        fillOpacity: 0.09,
                        opacity: 0.4,
                        className: "marine-zone-outline"
                    }
                }).addTo(map);
            }
            if (cwaFeatureCollection && cwaFeatureCollection.features.length > 0) {
                cwaLayer = L.geoJSON(cwaFeatureCollection, {
                    style: {
                        color: "#000",
                        weight: 1,
                        fillColor: "#fff",
                        fillOpacity: 0,
                        opacity: 0.13,
                        className: "cwa-outline"
                    }
                }).addTo(map);
            }
        }

        function addCityPointsLayer(cityPoints) {
            if (cityPointsLayer) {
                cityPointsLayer.clearLayers();
                map.removeLayer(cityPointsLayer);
                cityPointsLayer = null;
            }
            if (!cityPoints || cityPoints.length === 0) return;
            cityPointsLayer = L.layerGroup();
            cityPoints.forEach(pt => {
                let circle = L.circleMarker([pt.lat, pt.lng], {
                    radius: 6,
                    color: "#444",
                    fillColor: "#ffb700",
                    fillOpacity: 0.95,
                    weight: 2
                });
                if (pt.properties) {
                    circle.bindPopup(createCountyPopupContent(pt.properties));
                    circle.on("mouseover", function(e) {
                        showSimpleInfoPanel(pt.properties, e.latlng);
                    });
                    circle.on("mouseout", function() {
                        hideInfoPanel();
                    });
                    addLayerEventListeners(circle, pt.properties);
                }
                cityPointsLayer.addLayer(circle);
            });
            cityPointsLayer.addTo(map);
        }

        function addLayerEventListeners(layer, properties) {
            layer.on("mouseover", function(e) {
                showSimpleInfoPanel(properties, e.latlng);
            });
            layer.on("mouseout", function() {
                hideInfoPanel();
            });
        }

        function updateFiltersAndLegend() {
            const filtersContainer = document.getElementById("alert-filters");
            const legendContainer = document.getElementById("legend-items");
            filtersContainer.innerHTML = "";
            legendContainer.innerHTML = "";
            Object.keys(alertTypes).sort().forEach(alertType => {
                const style = getAlertStyle({ event: alertType });
                const filterDiv = document.createElement("div");
                filterDiv.className = "filter-checkbox";
                filterDiv.innerHTML = `
                    <input type="checkbox" id="filter-${alertType.replace(/\s+/g, "-")}" 
                           checked onchange="toggleAlertType('${alertType}')">
                    <label for="filter-${alertType.replace(/\s+/g, "-")}">${alertType}</label>
                `;
                filtersContainer.appendChild(filterDiv);
                const legendItem = document.createElement("div");
                legendItem.className = "legend-item";
                legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${style.color}; 
                         ${style.dashArray ? `border: 2px dashed ${style.color};` : ""}"></div>
                    <span>${alertType}</span>
                `;
                legendContainer.appendChild(legendItem);
            });
        }

        window.toggleAlertType = function(alertType) {
            renderAlerts();
        }

        function createCountyPopupContent(properties) {
            return `
                <div>
                    <h3>${properties.event || ""}</h3>
                    <p><strong>Start:</strong> ${properties.effective ? new Date(properties.effective).toLocaleString() : "-"}</p>
                    <p><strong>End:</strong> ${properties.expires ? new Date(properties.expires).toLocaleString() : "-"}</p>
                    <p><strong>Severity:</strong> ${properties.severity || "-"}</p>
                    <p><strong>Confidence:</strong> ${properties.certainty || "-"}</p>
                    <p><strong>Details:</strong> ${properties.headline || (properties.description ? properties.description.substring(0, 100) + "..." : "-")}</p>
                    <p><strong>Instructions:</strong> ${properties.instruction || "-"}</p>
                    <p><strong>Issuer:</strong> ${properties.senderName || "-"}</p>
                </div>
            `;
        }

        function showSimpleInfoPanel(properties, latlng) {
            const infoPanel = document.getElementById("info-panel");
            infoPanel.innerHTML = `
                <h3>${properties.event || ""}</h3>
                <p><strong>Start:</strong> ${properties.effective ? new Date(properties.effective).toLocaleString() : "-"}</p>
                <p><strong>End:</strong> ${properties.expires ? new Date(properties.expires).toLocaleString() : "-"}</p>
                <p><strong>Severity:</strong> ${properties.severity || "-"}</p>
                <p><strong>Confidence:</strong> ${properties.certainty || "-"}</p>
            `;
            const point = map.latLngToContainerPoint(latlng);
            infoPanel.style.left = (point.x + 10) + "px";
            infoPanel.style.top = (point.y + 10) + "px";
            infoPanel.style.display = "block";
        }

        function createPopupContent(properties) {
            return `
                <div>
                    <h3>${properties.event}</h3>
                    <p><strong>Area:</strong> ${properties.areaDesc}</p>
                    <p><strong>Severity:</strong> ${properties.severity}</p>
                    <p><strong>Effective:</strong> ${new Date(properties.effective).toLocaleString()}</p>
                    <p><strong>Expires:</strong> ${new Date(properties.expires).toLocaleString()}</p>
                    <p>${properties.description}</p>
                    ${properties.instruction ? `<p><a href="${properties.instruction}" target="_blank">Instructions</a></p>` : ""}
                </div>
            `;
        }

        function showInfoPanel(properties, latlng) {
            showSimpleInfoPanel(properties, latlng);
        }

        function hideInfoPanel() {
            document.getElementById("info-panel").style.display = "none";
        }

        function checkUserInAlertArea() {
            if (!userLocation || typeof userLocation.lat !== "number" || typeof userLocation.lng !== "number") {
                return;
            }
            const banner = document.getElementById("alert-banner");
            let userInAlert = false;
            let highestSeverityAlert = null;
            for (const id in alertLayers) {
                const layer = alertLayers[id];
                if (layer && (layer instanceof L.Polygon || layer instanceof L.FeatureGroup)) {
                    try {
                        if (layer.getBounds().contains([userLocation.lat, userLocation.lng])) {
                            userInAlert = true;
                            const popupContent = layer.getPopup().getContent();
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(popupContent, "text/html");
                            const eventType = doc.querySelector("h3").textContent;
                            const severity = doc.querySelector("p:nth-child(3)").textContent.replace("Severity: ", "");
                            if (!highestSeverityAlert) {
                                highestSeverityAlert = {id, eventType, severity};
                            } else if (severity === "Extreme" && highestSeverityAlert.severity !== "Extreme") {
                                highestSeverityAlert = {id, eventType, severity};
                            } else if (severity === "Severe" && highestSeverityAlert.severity !== "Extreme" && 
                                      highestSeverityAlert.severity !== "Severe") {
                                highestSeverityAlert = {id, eventType, severity};
                            }
                        }
                    } catch (error) {}
                }
            }
            if (userInAlert && highestSeverityAlert) {
                const alert = highestSeverityAlert;
                banner.innerHTML = `
                    <strong>${alert.eventType}</strong> is in effect for your location. 
                    <a href="#" onclick="focusOnAlert('${alert.id}')">View details</a>
                `;
                banner.classList.add("active");
            } else {
                banner.classList.remove("active");
            }
        }

        window.focusOnAlert = function(alertId) {
            const layer = alertLayers[alertId];
            if (layer) {
                if (layer.getBounds) map.fitBounds(layer.getBounds());
                layer.openPopup();
            }
        }

        const style = document.createElement("style");
        style.textContent = `
            .pulsing-layer {
                animation: pulse-animation 2s infinite;
            }
            @keyframes pulse-animation {
                0% { opacity: 0.7; }
                50% { opacity: 0.3; }
                100% { opacity: 0.7; }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
