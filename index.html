<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Severe Weather Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="icon" type="image/png" href="/public/assets/web_presence/icons/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/public/assets/web_presence/icons/favicon.svg" />
    <link rel="shortcut icon" href="/public/assets/web_presence/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/public/assets/web_presence/icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="SVR WX" />
    <link rel="manifest" href="/public/assets/web_presence/icons/site.webmanifest" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { display: flex; flex-direction: column; height: 100vh; background-color: #f0f2f5; }
        header { background: linear-gradient(to right, #2c3e50, #4a6491); color: white; padding: 1rem; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 10px rgba(0,0,0,0.2);}
        .logo { display: flex; align-items: center; gap: 0.5rem; }
        .logo i { font-size: 1.8rem; }
        .address-form { display: flex; gap: 0.5rem; }
        .address-input { padding: 0.5rem; border: none; border-radius: 4px; width: 250px; }
        button { background-color: #3498db; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; }
        button:hover { background-color: #2980b9; }
        .alert-banner { background-color: #e74c3c; color: white; padding: 0.8rem; text-align: center; display: none; box-shadow: 0 2px 5px rgba(0,0,0,0.2); position: relative; z-index: 1000; }
        .alert-banner.active { display: block; animation: pulse 2s infinite; }
        @keyframes pulse { 0% {opacity:1;} 50% {opacity:0.8;} 100% {opacity:1;} }
        .map-container { flex: 1; position: relative; }
        #map { height: 100%; width: 100%; background: #e8e8e8; }
        .info-panel { position: absolute; top: 1rem; right: 1rem; background-color: white; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000; max-width: 300px; display: none; }
        .info-panel h3 { margin-bottom: 0.5rem; color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 0.5rem; }
        .info-panel p { margin: 0.3rem 0; color: #34495e; }
        
        /* Updated Filter Panel Styles */
        .filter-panel {
            position: absolute;
            top: 1rem;
            left: 0;
            background-color: white;
            padding: 1rem;
            border-radius: 0 8px 8px 0;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            width: 200px;
            max-height: 80vh;
            overflow-y: auto;
            transition: left 0.3s ease;
        }
        
        .filter-panel.collapsed {
            left: -200px;
        }
        
        .filter-panel h3 {
            margin-bottom: 0.5rem;
            color: #2c3e50;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .filter-panel h3::after {
            content: '‚óÄ';
            font-weight: bold;
            font-size: 1rem;
        }
        
        .filter-panel.collapsed h3::after {
            content: '‚ñ∂';
        }
        
        /* Updated Legend Styles */
        .legend {
            position: absolute;
            bottom: 1rem;
            right: 0;
            background-color: white;
            padding: 1rem;
            border-radius: 8px 0 0 8px;
            box-shadow: -2px 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            width: 200px;
            max-height: 300px;
            overflow-y: auto;
            transition: right 0.3s ease;
        }
        
        .legend.collapsed {
            right: -200px;
        }
        
        .legend h3 {
            margin-bottom: 0.5rem;
            color: #2c3e50;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .legend h3::after {
            content: '‚ñ∂';
            font-weight: bold;
            font-size: 1rem;
        }
        
        .legend.collapsed h3::after {
            content: '‚óÄ';
        }
        
        .collapse-toggle {
            cursor: pointer;
            user-select: none;
        }
        
        /* Sidebar toggle buttons */
        .sidebar-toggle {
            position: absolute;
            background-color: white;
            border-radius: 0 4px 4px 0;
            padding: 0.5rem;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            z-index: 999;
            cursor: pointer;
            display: none;
            width: 24px;
            height: 40px;
            text-align: center;
            line-height: 30px;
        }
        
        .filter-toggle {
            top: 1rem;
            left: 0;
        }
        
        .legend-toggle {
            bottom: 1rem;
            right: 0;
            border-radius: 4px 0 0 4px;
        }
        
        .filter-panel.collapsed ~ .filter-toggle,
        .legend.collapsed ~ .legend-toggle {
            display: block;
        }
        
        .legend-item { display: flex; align-items: center; margin: 0.3rem 0; }
        .legend-color { width: 20px; height: 20px; margin-right: 0.5rem; border-radius: 3px; border: 1px solid #888; }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(255,255,255,0.9); padding: 1rem 2rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000; display: none; }
        
        /* Positioning for controls */
        .refresh-info { 
            position: absolute; 
            bottom: 1rem; 
            left: 1rem;
            background-color: rgba(255,255,255,0.8); 
            padding: 0.5rem 1rem; 
            border-radius: 8px; 
            font-size: 0.9rem; 
            z-index: 1000; 
            transition: left 0.3s ease;
        }
        
        .progress-bar { 
            position: absolute; 
            bottom: 3.5rem; 
            left: 1rem;
            width: 200px; 
            height: 10px; 
            background-color: #f0f0f0; 
            border-radius: 5px; 
            overflow: hidden; 
            z-index: 1000; 
            transition: left 0.3s ease;
        }
        
        .api-status { 
            position: absolute; 
            bottom: 5rem; 
            left: 1rem;
            background-color: rgba(255,255,255,0.8); 
            padding: 0.5rem 1rem; 
            border-radius: 8px; 
            font-size: 0.8rem; 
            z-index: 1000; 
            transition: left 0.3s ease;
        }
        
        .view-toggle { 
            position: absolute; 
            top: 1rem; 
            left: 220px;
            background: white; 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.15); 
            z-index: 1001; 
            padding: 0.5rem 1rem; 
            display: flex; 
            align-items: center; 
            gap: 0.5rem; 
            transition: left 0.3s ease;
        }
        
        /* Position elements when filter panel is open */
        .filter-panel:not(.collapsed) ~ .refresh-info,
        .filter-panel:not(.collapsed) ~ .progress-bar,
        .filter-panel:not(.collapsed) ~ .api-status,
        .filter-panel:not(.collapsed) ~ .view-toggle {
            left: 220px;
        }
        
        /* Position elements when filter panel is closed */
        .filter-panel.collapsed ~ .refresh-info,
        .filter-panel.collapsed ~ .progress-bar,
        .filter-panel.collapsed ~ .api-status {
            left: 1rem;
        }
        
        .filter-panel.collapsed ~ .view-toggle {
            left: 1rem;
        }
        
        .filter-checkbox { margin: 0.3rem 0; }
        
        .county-outline { color: #222; weight: 1.5; fill: #fff; fillOpacity: 0; opacity: 0.7; pointer-events: none; }
        .inactive-county { fill: #fff; fill-opacity: 0.7; opacity: 0.6; pointer-events: none; }
        .active-county { fill-opacity: 0.7; opacity: 1; pointer-events: auto; }
        .marine-zone-outline { color: #11b6e8; weight: 1.3; fill: #b6f1ff; fill-opacity: 0.18; opacity: 0.8; pointer-events: none; }
        .alert-instructions-link {
            color: #3498db;
            text-decoration: underline;
            cursor: pointer;
            font-weight: bold;
        }
        .alert-instructions-link:hover {
            color: #1d6fa5;
        }
        .banner-alert-selector {
            margin-left: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            padding: 2px 8px;
            color: white;
            cursor: pointer;
        }
        .banner-alert-selector:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">
            <i>üå™Ô∏è</i>
            <h1>Severe Weather Tracker</h1>
        </div>
        <div class="address-form">
            <input type="text" class="address-input" placeholder="Enter your address" id="address-input">
            <button id="save-address">Save Location</button>
        </div>
    </header>
    <div class="alert-banner" id="alert-banner"></div>
    <div class="map-container">
        <div id="map"></div>
        <div class="info-panel" id="info-panel"></div>
        <div class="filter-panel">
            <h3 class="collapse-toggle">Filter Alerts</h3>
            <div id="alert-filters"></div>
        </div>
        <div class="sidebar-toggle filter-toggle">‚ñ∂</div>
        
        <div class="view-toggle">
            <label for="view-mode">View Mode:</label>
            <select id="view-mode">
                <option value="polygon" selected>Polygon</option>
                <option value="county">Active County</option>
            </select>
        </div>
        <div class="legend">
            <h3 class="collapse-toggle">Legend</h3>
            <div id="legend-items"></div>
        </div>
        <div class="sidebar-toggle legend-toggle">‚óÄ</div>
        
        <div class="refresh-info">
            Data refreshes every minute. Last updated: <span id="last-updated">-</span>
        </div>
        <div class="progress-bar">
            <div class="progress" id="progress-bar"></div>
        </div>
        <div class="loading" id="loading">
            Loading weather data...
        </div>
    </div>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <script>
        const IMPORTANT_ALERT_TYPES = [
            "Tornado Warning",
            "Tornado Watch",
            "Tornado Emergency",
            "Flood Warning",
            "Flood Watch",
            "Flood Advisory",
            "Flash Flood Warning",
            "Flash Flood Watch",
            "Flash Flood Statement",
            "Hurricane Warning",
            "Hurricane Watch",
            "Tropical Storm Warning",
            "Tropical Storm Watch",
            "Tsunami Warning",
            "Tsunami Watch",
            "Tsunami Advisory",
            "Tsunami Information Statement",
            "Earthquake Warning",
            "Earthquake Advisory",
            "Earthquake Watch"
        ];
        const map = L.map('map', { zoomSnap: 0.1, preferCanvas: true }).setView([39.8283, -98.5795], 4);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        let alertLayers = {};
        let userMarker = null;
        let userLocation = null;
        let alertTypes = {};
        let countyGeojson = null;
        let countyFeatureCollection = null;
        let cwaGeojson = null;
        let cwaFeatureCollection = null;
        let marineZonesGeojson = null;
        let marineZonesFeatureCollection = null;
        let allAlerts = [];
        let polygonMode = true;
        let countyOutlinesLayer = null;
        let marineZonesLayer = null;
        let cwaLayer = null;
        let countyActiveLayer = null;
        let cityPointsLayer = null;
        let alertPolygonLayer = null;
        let affectedZoneLayer = null;
        let currentBannerAlertIndex = 0;
        let userAlerts = [];

        const alertStyles = {
            "Tornado Warning": { color: "#ff0000", className: "pulsing-layer", severityRank: 1 },
            "Tornado Watch": { color: "#ffcc00", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 2 },
            "Tornado Emergency": { color: "#cc00ff", className: "pulsing-layer", severityRank: 0 },
            "Flash Flood Warning": { color: "#880000", className: "pulsing-layer", severityRank: 2 },
            "Flood Advisory": { color: "#ffff00", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 5 },
            "Flood Watch": { color: "#aaff00", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 4 },
            "Flood Warning": { color: "#007700", className: "pulsing-layer", severityRank: 2 },
            "Flash Flood Watch": { color: "#aaff00", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 4 },
            "Flash Flood Statement": { color: "#bbff99", dashArray: "5, 5", fillOpacity: 0.2, severityRank: 6 },
            "Coastal Flood Advisory": { color: "#77aaff", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 5 },
            "Coastal Flood Warning": { color: "#0055ff", className: "pulsing-layer", severityRank: 2 },
            "Coastal Flood Statement": { color: "#aaccff", dashArray: "5, 5", fillOpacity: 0.2, severityRank: 6 },
            "Severe Thunderstorm Warning": { color: "#ff0000", dashArray: "10, 10", className: "pulsing-layer", severityRank: 2 },
            "Severe Thunderstorm Watch": { color: "#ffcc00", fillOpacity: 0.3, severityRank: 3 },
            "Special Weather Statement": { color: "#cccccc", dashArray: "5, 5", fillOpacity: 0.2, severityRank: 7 },
            "Winter Storm Warning": { color: "#00aaff", className: "pulsing-layer", severityRank: 2 },
            "Winter Storm Watch": { color: "#00ccff", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 3 },
            "Winter Weather Advisory": { color: "#00ffff", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 4 },
            "Blizzard Warning": { color: "#ffffff", className: "pulsing-layer", severityRank: 1 },
            "Wind Advisory": { color: "#ffaa00", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 5 },
            "High Wind Warning": { color: "#ff7700", className: "pulsing-layer", severityRank: 2 },
            "Gale Warning": { color: "#0077ff", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 3 },
            "Gale Watch": { color: "#0055cc", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 4 },
            "Small Craft Advisory": { color: "#5555ff", dashArray: "5, 5", fillOpacity: 0.3, severityRank: 6 },
            "Marine Weather Statement": { color: "#aaaaff", dashArray: "5, 5", fillOpacity: 0.2, severityRank: 8 },
            "Tropical Storm Warning": { color: "#00ddcc", className: "pulsing-layer", severityRank: 1 },
            "Tropical Storm Watch": { color: "#00ffee", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 3 },
            "Hurricane Warning": { color: "#ff0000", className: "pulsing-layer", severityRank: 0 },
            "Hurricane Watch": { color: "#ff8888", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 2 },
            "Tsunami Warning": { color: "#0033ff", className: "pulsing-layer", severityRank: 1 },
            "Tsunami Watch": { color: "#66ccff", dashArray: "10, 10", fillOpacity: 0.3, severityRank: 2 },
            "Tsunami Advisory": { color: "#b3d9ff", dashArray: "5, 5", fillOpacity: 0.2, severityRank: 4 },
            "Tsunami Information Statement": { color: "#b3d9ff", dashArray: "5, 5", fillOpacity: 0.2, severityRank: 5 },
            "Earthquake Warning": { color: "#ec7c07", className: "pulsing-layer", severityRank: 1 },
            "Earthquake Advisory": { color: "#f2b134", dashArray: "5,5", fillOpacity: 0.3, severityRank: 2 },
            "Earthquake Watch": { color: "#f2b134", dashArray: "10,10", fillOpacity: 0.3, severityRank: 3 },
            "_default": { color: "#5555ff", fillOpacity: 0.3, severityRank: 99 }
        };

        let marineZoneLookup = {};
        let cwaLookup = {};
        let countyLookup = {};

        const STATE_ABBRS = [
            "AL","AK","AZ","AR","CA","CO","CT","DE","FL","GA","HI","ID","IL","IN","IA","KS","KY","LA","ME","MD",
            "MA","MI","MN","MS","MO","MT","NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK","OR","PA","RI","SC",
            "SD","TN","TX","UT","VT","VA","WA","WV","WI","WY","DC","PR","VI","GU","AS","MP"
        ];
        // Add toggle functionality for filter and legend panels
        function setupCollapsiblePanels() {
            const filterPanel = document.querySelector('.filter-panel');
            const legendPanel = document.querySelector('.legend');
            const filterToggle = document.querySelector('.filter-toggle');
            const legendToggle = document.querySelector('.legend-toggle');
            
            // Toggle filter panel
            const filterHeader = filterPanel.querySelector('h3');
            filterHeader.addEventListener('click', function() {
                filterPanel.classList.toggle('collapsed');
            });
            
            // Toggle filter panel from external button
            filterToggle.addEventListener('click', function() {
                filterPanel.classList.remove('collapsed');
            });
            
            // Toggle legend panel
            const legendHeader = legendPanel.querySelector('h3');
            legendHeader.addEventListener('click', function() {
                legendPanel.classList.toggle('collapsed');
            });
            
            // Toggle legend panel from external button
            legendToggle.addEventListener('click', function() {
                legendPanel.classList.remove('collapsed');
            });
            
            // Initialize both panels as expanded by default
            filterPanel.classList.remove('collapsed');
            legendPanel.classList.remove('collapsed');
            
            // Close panels when clicking outside
            document.addEventListener('click', function(event) {
                if (!filterPanel.contains(event.target) && event.target !== filterToggle) {
                    filterPanel.classList.add('collapsed');
                }
                if (!legendPanel.contains(event.target) && event.target !== legendToggle) {
                    legendPanel.classList.add('collapsed');
                }
            });
            
            // Prevent clicks inside panels from closing them
            filterPanel.addEventListener('click', function(event) {
                event.stopPropagation();
            });
            
            legendPanel.addEventListener('click', function(event) {
                event.stopPropagation();
            });
        }
        // Add this function to initialize the panels in collapsed state
        function initializePanels() {
            const filterPanel = document.querySelector('.filter-panel');
            const legendPanel = document.querySelector('.legend');
            
            // Start with both panels collapsed
            filterPanel.classList.add('collapsed');
            legendPanel.classList.add('collapsed');
        }


        function getAlertStyle(properties) {
            const eventType = properties.event;
            const styleConfig = alertStyles[eventType] || alertStyles["_default"];
            return {
                color: styleConfig.color,
                weight: 3,
                opacity: 1,
                fillColor: styleConfig.color,
                fillOpacity: styleConfig.fillOpacity || 0.3,
                dashArray: styleConfig.dashArray,
                className: styleConfig.className,
                severityRank: styleConfig.severityRank !== undefined ? styleConfig.severityRank : 99
            };
        }

        document.addEventListener("DOMContentLoaded", function() {
            const savedAddress = localStorage.getItem("weatherTrackerAddress");
            if (savedAddress) {
                document.getElementById("address-input").value = savedAddress;
                geocodeAddress(savedAddress);
            }
            document.getElementById("save-address").addEventListener("click", saveAddress);
            const savedCount = localStorage.getItem("geoapifyRequestCount");
            if (savedCount) {
                geoapifyRequestCount = parseInt(savedCount);
                document.getElementById("geoapify-count").textContent = geoapifyRequestCount;
            }
        
            const savedViewMode = localStorage.getItem("weatherTrackerViewMode");
            if (savedViewMode) {
                document.getElementById("view-mode").value = savedViewMode;
                polygonMode = savedViewMode === "polygon";
            }
        
            document.getElementById("view-mode").addEventListener("change", function() {
                polygonMode = this.value === "polygon";
                localStorage.setItem("weatherTrackerViewMode", this.value);
                renderAlerts();
            });
        
            // Initialize panels first, then load data
            initializePanels();
            setupCollapsiblePanels();
            
            Promise.all([
                loadAllCountyBoundaries(),
                loadMarineZones(),
                loadCWABoundaries()
            ]).then(() => fetchWeatherData());
            setInterval(fetchWeatherData, 60000);
        });
        async function loadAllCountyBoundaries() {
            countyLookup = {};
            let features = [];
            let fetchCount = 0;
            for (let abbr of STATE_ABBRS) {
                try {
                    const url = `https://raw.githubusercontent.com/Bella288/svr-wx-data/main/counties_${abbr}.geojson`;
                    const response = await fetch(url);
                    if (response.ok) {
                        const geojson = await response.json();
                        if (geojson.features && Array.isArray(geojson.features)) {
                            for (const feature of geojson.features) {
                                let fips = "";
                                if (feature.properties) {
                                    if (feature.properties.GEOID) {
                                        fips = feature.properties.GEOID;
                                    } else if (feature.properties.FIPS) {
                                        fips = feature.properties.FIPS;
                                    }
                                    if (fips) countyLookup[fips] = feature;
                                }
                                features.push(feature);
                            }
                        }
                        fetchCount++;
                        // Update progress bar - make sure this line is present
                        document.getElementById("progress-bar").style.width = `${Math.round((fetchCount / STATE_ABBRS.length) * 100)}%`;
                    }
                } catch (error) {
                    console.error("Error loading county data for", abbr, error);
                }
            }
            countyFeatureCollection = { type: "FeatureCollection", features };
        }

        async function loadMarineZones() {
            try {
                const url = "https://raw.githubusercontent.com/Bella288/svr-wx-data/main/marine_zones_us.geojson";
                const resp = await fetch(url);
                marineZonesGeojson = await resp.json();
                marineZonesFeatureCollection = marineZonesGeojson;
                marineZoneLookup = {};
                if (marineZonesFeatureCollection && marineZonesFeatureCollection.features) {
                    marineZonesFeatureCollection.features.forEach(f => {
                        if (f.properties && f.properties.ZONE) {
                            marineZoneLookup[f.properties.ZONE] = f;
                        }
                    });
                }
            } catch (error) {
                marineZonesGeojson = { type: "FeatureCollection", features: [] };
                marineZoneLookup = {};
            }
        }

        async function loadCWABoundaries() {
            try {
                const url = "https://raw.githubusercontent.com/Bella288/svr-wx-data/main/nws_cwa.geojson";
                const resp = await fetch(url);
                cwaGeojson = await resp.json();
                cwaFeatureCollection = cwaGeojson;
                cwaLookup = {};
                if (cwaFeatureCollection && cwaFeatureCollection.features) {
                    cwaFeatureCollection.features.forEach(f => {
                        if (f.properties && f.properties.CWA) {
                            cwaLookup[f.properties.CWA] = f;
                        }
                    });
                }
            } catch (error) {
                cwaGeojson = { type: "FeatureCollection", features: [] };
                cwaLookup = {};
            }
        }

        function saveAddress() {
            const address = document.getElementById("address-input").value;
            if (address.trim() !== "") {
                localStorage.setItem("weatherTrackerAddress", address);
                geocodeAddress(address);
            }
        }

        function geocodeAddress(address) {
            document.getElementById("loading").style.display = "block";
            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`)
                .then(response => response.json())
                .then(data => {
                    if (data && data.length > 0) {
                        const lat = parseFloat(data[0].lat);
                        const lon = parseFloat(data[0].lon);
                        userLocation = { lat, lng: lon };
                        map.setView([lat, lon], 9);
                        if (userMarker) map.removeLayer(userMarker);
                        userMarker = L.marker([lat, lon]).addTo(map).bindPopup("Your location").openPopup();
                        checkUserInAlertArea();
                    } else {
                        alert("Address not found. Please try a more specific address.");
                    }
                })
                .catch(error => {
                    alert("Error finding address. Please try again.");
                })
                .finally(() => {
                    document.getElementById("loading").style.display = "none";
                });
        }

        async function fetchZoneGeometry(url) {
            try {
                let resp = await fetch(url);
                if (!resp.ok) return null;
                let data = await resp.json();
                if (data.geometry && (data.geometry.type === "Polygon" || data.geometry.type === "MultiPolygon")) {
                    return data.geometry;
                }
            } catch (e) {}
            return null;
        }

        function fetchWeatherData() {
            document.getElementById("loading").style.display = "block";
            Object.keys(alertLayers).forEach(id => {
                try { map.removeLayer(alertLayers[id]); } catch {}
            });
            if (countyActiveLayer) {
                countyActiveLayer.clearLayers();
                map.removeLayer(countyActiveLayer);
                countyActiveLayer = null;
            }
            if (countyOutlinesLayer) {
                countyOutlinesLayer.clearLayers();
                map.removeLayer(countyOutlinesLayer);
                countyOutlinesLayer = null;
            }
            if (cityPointsLayer) { cityPointsLayer.clearLayers(); map.removeLayer(cityPointsLayer); cityPointsLayer = null; }
            if (alertPolygonLayer) { alertPolygonLayer.clearLayers(); map.removeLayer(alertPolygonLayer); alertPolygonLayer = null; }
            if (affectedZoneLayer) { affectedZoneLayer.clearLayers(); map.removeLayer(affectedZoneLayer); affectedZoneLayer = null; }
            alertLayers = {};
            alertTypes = {};
            allAlerts = [];
            document.getElementById("progress-bar").style.width = "0%";
            fetch("https://api.weather.gov/alerts/active")
                .then(r => r.json())
                .then(data => {
                    allAlerts = (data.features || []);
                    if (!allAlerts.length) {
                        document.getElementById("loading").style.display = "none";
                        return;
                    }
                    renderAlerts();
                    document.getElementById("last-updated").textContent = new Date().toLocaleTimeString();
                    document.getElementById("progress-bar").style.width = "100%";
                    document.getElementById("loading").style.display = "none";
                })
                .catch(e => {
                    document.getElementById("loading").style.display = "none";
                });
        }

        function renderAlerts() {
            Object.keys(alertLayers).forEach(id => {
                try { map.removeLayer(alertLayers[id]); } catch {}
            });
            alertLayers = {};
            alertTypes = {};
            if (countyActiveLayer) {
                countyActiveLayer.clearLayers();
                map.removeLayer(countyActiveLayer);
                countyActiveLayer = null;
            }
            if (countyOutlinesLayer) {
                countyOutlinesLayer.clearLayers();
                map.removeLayer(countyOutlinesLayer);
                countyOutlinesLayer = null;
            }
            if (cityPointsLayer) { cityPointsLayer.clearLayers(); map.removeLayer(cityPointsLayer); cityPointsLayer = null; }
            if (alertPolygonLayer) { alertPolygonLayer.clearLayers(); map.removeLayer(alertPolygonLayer); alertPolygonLayer = null; }
            if (affectedZoneLayer) { affectedZoneLayer.clearLayers(); map.removeLayer(affectedZoneLayer); affectedZoneLayer = null; }
            allAlerts.forEach(alert => {
                const event = alert.properties.event;
                alertTypes[event] = true;
            });
            updateFiltersAndLegend();
            if (polygonMode) {
                allAlerts.forEach(alert => {
                    processAlertForView(alert, true);
                });
            } else {
                renderActiveCountyView();
            }
            if (userLocation) checkUserInAlertArea();
        }

        function processAlertForView(alert, polygonMode = true) {
            const properties = alert.properties;
            const geometry = alert.geometry;
            const eventType = properties.event;
            const style = getAlertStyle(properties);
            let layer = null;
            let show = true;
            const filterCheckbox = document.getElementById("filter-" + eventType.replace(/\s+/g, "-"));
            if (filterCheckbox && !filterCheckbox.checked) show = false;
            if (polygonMode) {
                if (geometry && (geometry.type === "Polygon" || geometry.type === "MultiPolygon")) {
                    if (geometry.type === "Polygon") {
                        const coordinates = geometry.coordinates[0];
                        const latLngs = coordinates.map(coord => [coord[1], coord[0]]);
                        layer = L.polygon(latLngs, style)
                                .bindPopup(createPopupContent(properties));
                    } else if (geometry.type === "MultiPolygon") {
                        const polygons = geometry.coordinates.map(polygonCoords => {
                            const latLngs = polygonCoords[0].map(coord => [coord[1], coord[0]]);
                            return L.polygon(latLngs, style);
                        });
                        layer = L.featureGroup(polygons).bindPopup(createPopupContent(properties));
                    }
                } else {
                    let polygons = [];
                    if (properties.geocode && properties.geocode.UGC && countyLookup && countyFeatureCollection) {
                        properties.geocode.UGC.forEach(ugcCode => {
                            if (ugcCode.length === 6) {
                                const stateCode = ugcCode.substring(0, 2);
                                const countyCode = ugcCode.substring(2);
                                const fipsCode = stateCode + countyCode;
                                const countyGeometry = countyLookup[fipsCode];
                                if (countyGeometry) {
                                    const countyLayer = L.geoJSON(countyGeometry, {
                                        style: style,
                                        onEachFeature: function(feature, layer) {
                                            layer.bindPopup(createPopupContent(properties));
                                        }
                                    });
                                    polygons.push(countyLayer);
                                }
                            }
                        });
                    }
                    if (properties.geocode && properties.geocode.FIPS && countyFeatureCollection) {
                        properties.geocode.FIPS.forEach(fipsCode => {
                            const countyGeometry = countyLookup[fipsCode];
                            if (countyGeometry) {
                                const countyLayer = L.geoJSON(countyGeometry, {
                                    style: style,
                                    onEachFeature: function(feature, layer) {
                                        layer.bindPopup(createPopupContent(properties));
                                    }
                                });
                                polygons.push(countyLayer);
                            }
                        });
                    }
                    if (properties.geocode && properties.geocode.MARINE && marineZoneLookup && marineZonesFeatureCollection) {
                        properties.geocode.MARINE.forEach(zoneCode => {
                            const marineFeat = marineZoneLookup[zoneCode];
                            if (marineFeat) {
                                const marineLayer = L.geoJSON(marineFeat, {
                                    style: {
                                        color: "#11b6e8",
                                        weight: 2,
                                        fillColor: "#b6f1ff",
                                        fillOpacity: 0.18,
                                        opacity: 0.8,
                                        className: "marine-zone-outline"
                                    },
                                    onEachFeature: function(feature, l) {
                                        l.bindPopup(createPopupContent(properties));
                                    }
                                });
                                polygons.push(marineLayer);
                            }
                        });
                    }
                    if (properties.geocode && properties.geocode.CWA && cwaLookup && cwaFeatureCollection) {
                        properties.geocode.CWA.forEach(cwaCode => {
                            const cwaFeat = cwaLookup[cwaCode];
                            if (cwaFeat) {
                                const cwaLayer = L.geoJSON(cwaFeat, {
                                    style: {
                                        color: "#222",
                                        weight: 2,
                                        fillColor: style.color,
                                        fillOpacity: 0.22,
                                        opacity: 0.6,
                                        className: "cwa-outline"
                                    },
                                    onEachFeature: function(feature, l) {
                                        l.bindPopup(createPopupContent(properties));
                                    }
                                });
                                polygons.push(cwaLayer);
                            }
                        });
                    }
                    if (polygons.length > 0) {
                        layer = L.featureGroup(polygons);
                    }
                }
            }
            if (layer && show) {
                addLayerEventListeners(layer, properties);
                alertLayers[properties.id] = layer;
                layer.addTo(map);
            }
        }

        function createPopupContent(properties) {
            return `
                <div>
                    <h3>${properties.event}</h3>
                    <p><strong>Area:</strong> ${properties.areaDesc}</p>
                    <p><strong>Severity:</strong> ${properties.severity}</p>
                    <p><strong>Effective:</strong> ${new Date(properties.effective).toLocaleString()}</p>
                    <p><strong>Expires:</strong> ${new Date(properties.expires).toLocaleString()}</p>
                    <p>${properties.description}</p>
                    ${properties.instruction ? `<p><span class="alert-instructions-link" onclick="redirectToAlertDetails(this)">Instructions</span></p>` : ""}
                </div>
            `;
        }

        function createCountyPopupContent(properties) {
            return `
                <div>
                    <h3>${properties.event || ""}</h3>
                    <p><strong>Area:</strong> ${properties.areaDesc || "-"}</p>
                    <p><strong>Effective:</strong> ${properties.effective ? new Date(properties.effective).toLocaleString() : "-"}</p>
                    <p><strong>Expires:</strong> ${properties.expires ? new Date(properties.expires).toLocaleString() : "-"}</p>
                    <p><strong>Severity:</strong> ${properties.severity || "-"}</p>
                    <p><strong>Certainty:</strong> ${properties.certainty || "-"}</p>
                    <p>${properties.headline || (properties.description ? properties.description.substring(0, 100) + "..." : "-")}</p>
                    <p><strong>Instructions:</strong> ${properties.instruction ? `<span class="alert-instructions-link" onclick="redirectToAlertDetails(this)">View Instructions</span>` : "-"}</p>
                    <p><strong>Issuer:</strong> ${properties.senderName || "-"}</p>
                </div>
            `;
        }

        function redirectToAlertDetails(el) {
            // Find the alert properties from the clicked element
            let popupDiv = el.closest(".leaflet-popup-content") || el.closest("div");
            let eventType = "";
            let areaDesc = "";
            let effective = "";
            let expires = "";
            
            // Try to extract information from the popup content
            if (popupDiv) {
                const h3 = popupDiv.querySelector("h3");
                if (h3) eventType = h3.textContent.trim();
                
                const paragraphs = popupDiv.querySelectorAll("p");
                paragraphs.forEach(p => {
                    const text = p.textContent;
                    if (text.includes("Area:")) areaDesc = text.replace("Area:", "").trim();
                    else if (text.includes("Effective:")) effective = text.replace("Effective:", "").trim();
                    else if (text.includes("Expires:")) expires = text.replace("Expires:", "").trim();
                });
            }
            
            // Find the matching alert in allAlerts
            let foundAlert = null;
            if (allAlerts && allAlerts.length) {
                for (const alert of allAlerts) {
                    const p = alert.properties;
                    if (!p) continue;
                    
                    // Try to match based on available information
                    const eventMatch = !eventType || p.event === eventType;
                    const areaMatch = !areaDesc || (p.areaDesc && p.areaDesc.includes(areaDesc));
                    const timeMatch = !effective || (p.effective && new Date(p.effective).toLocaleString() === effective);
                    
                    if (eventMatch && areaMatch && timeMatch) {
                        foundAlert = p;
                        break;
                    }
                }
            }
            
            // If we found an alert, extract all needed information
            if (foundAlert) {
                // Extract Movement, Impact, What, When, and Additional Details from description
                let movement = "";
                let impact = "";
                let what = "";
                let when = "";
                let additionalDetails = "";
                
                if (foundAlert.description) {
                    const desc = foundAlert.description;
                    
                    // Extract MOVEMENT if available
                    const movementMatch = desc.match(/moving\s+(?:[A-Za-z]*\s*)?(?:north|south|east|west|northeast|northwest|southeast|southwest)\s+at\s+(\d+\s*(?:mph|knots|km\/h))/i);
                    if (movementMatch) {
                        movement = movementMatch[0];
                    }
                    
                    // Extract IMPACT if available - FIXED REGEX
                    const impactMatch = desc.match(/(?:\* )?IMPACTS?[:\*\.\s]*([\s\S]*?)(?=\* ADDITIONAL|\* WHEN|\* WHERE|\* WHAT|\* Instructions|\* For more|\* To report|\* A|\* Stay|\* The|\* For your|\* \w+|\n\*|\z)/i) ||
                                       desc.match(/(?:\* )?EFFECT[:\*\.\s]*([\s\S]*?)(?=\* ADDITIONAL|\* WHEN|\* WHERE|\* WHAT|\* Instructions|\* For more|\* To report|\* A|\* Stay|\* The|\* For your|\* \w+|\n\*|\z)/i);
                    if (impactMatch) {
                        impact = impactMatch[1].trim();
                        // Clean up any trailing asterisks or section markers
                        impact = impact.replace(/\*[A-Z]+\s*:\s*$/, '').trim();
                    }
                    
                    // Extract WHAT if available - FIXED REGEX
                    const whatMatch = desc.match(/(?:\* )?WHAT[:\*\.\s]*([\s\S]*?)(?=\* WHERE|\* WHEN|\* IMPACTS|\* ADDITIONAL|\* Instructions|\* For more|\* To report|\* A|\* Stay|\* The|\* For your|\* \w+|\n\*|\z)/i);
                    if (whatMatch) {
                        what = whatMatch[1].trim();
                        what = what.replace(/\*[A-Z]+\s*:\s*$/, '').trim();
                    }
                    
                    // Extract WHEN if available - FIXED REGEX
                    const whenMatch = desc.match(/(?:\* )?WHEN[:\*\.\s]*([\s\S]*?)(?=\* WHAT|\* WHERE|\* IMPACTS|\* ADDITIONAL|\* Instructions|\* For more|\* To report|\* A|\* Stay|\* The|\* For your|\* \w+|\n\*|\z)/i);
                    if (whenMatch) {
                        when = whenMatch[1].trim();
                        when = when.replace(/\*[A-Z]+\s*:\s*$/, '').trim();
                    }
                    
                    // Extract ADDITIONAL DETAILS if available - FIXED REGEX
                    const additionalMatch = desc.match(/(?:\* )?ADDITIONAL DETAILS[:\*\.\s]*([\s\S]*?)(?=\* WHAT|\* WHERE|\* WHEN|\* IMPACTS|\* Instructions|\* For more|\* To report|\* A|\* Stay|\* The|\* For your|\* \w+|\n\*|\z)/i);
                    if (additionalMatch) {
                        additionalDetails = additionalMatch[1].trim();
                        additionalDetails = additionalDetails.replace(/\*[A-Z]+\s*:\s*$/, '').trim();
                    }
                }
                
                // Prepare the alert object with all needed fields
                const alertToSend = {
                    event: foundAlert.event || "",
                    effective: foundAlert.effective || "",
                    expires: foundAlert.expires || "",
                    senderName: foundAlert.senderName || "",
                    severity: foundAlert.severity || "",
                    certainty: foundAlert.certainty || "",
                    areaDesc: foundAlert.areaDesc || "",
                    description: foundAlert.description || "",
                    instruction: foundAlert.instruction || "",
                    headline: foundAlert.headline || "",
                    parameters: foundAlert.parameters || {},
                    movement: movement,
                    impact: impact,
                    what: what,
                    when: when,
                    additionalDetails: additionalDetails
                };
                
                try {
                    sessionStorage.setItem("selectedAlert", JSON.stringify(alertToSend));
                } catch (e) {
                    console.error("Error saving to sessionStorage:", e);
                }
                
                window.location.href = "/alert-details.html";
            } else {
                // Fallback: try to use the existing logic if no alert was found
                const pTags = popupDiv.querySelectorAll("p");
                let area = pTags[0] ? (pTags[0].textContent.replace(/^Area:\s*/, "") || "") : "";
                let effective = pTags[2] ? (pTags[2].textContent.replace(/^Effective:\s*/, "") || "") : "";
                let expires = pTags[3] ? (pTags[3].textContent.replace(/^Expires:\s*/, "") || "") : "";
                let description = pTags[4] ? (pTags[4].textContent || "") : "";
                
                const alertToSend = {
                    event: eventType,
                    areaDesc: area,
                    effective: effective,
                    expires: expires,
                    description: description
                };
                
                try {
                    sessionStorage.setItem("selectedAlert", JSON.stringify(alertToSend));
                } catch (e) {
                    console.error("Error saving to sessionStorage:", e);
                }
                
                window.location.href = "/alert-details.html";
            }
        }
        function renderActiveCountyView() {
            if (!countyFeatureCollection) return;
            countyOutlinesLayer = L.geoJSON(countyFeatureCollection, {
                style: function() {
                    return {
                        color: "#888",
                        weight: 1,
                        fillColor: "#fff",
                        fillOpacity: 0,
                        className: "county-outline"
                    };
                }
            }).addTo(map);

            let countyAlertsByFIPS = {};
            let alertGeometries = [];
            let cityPoints = [];
            let affectedZoneGeometriesPromises = [];
            let affectedZoneProps = [];

            allAlerts.forEach(alert => {
                const properties = alert.properties;
                const eventType = properties.event;
                const style = getAlertStyle(properties);
                let show = true;
                const filterCheckbox = document.getElementById("filter-" + eventType.replace(/\s+/g, "-"));
                if (filterCheckbox && !filterCheckbox.checked) show = false;
                if (!show) return;

                if (alert.geometry && (alert.geometry.type === "Polygon" || alert.geometry.type === "MultiPolygon")) {
                    alertGeometries.push({
                        geometry: alert.geometry,
                        style: style,
                        properties: properties
                    });
                }
                if ((!alert.geometry || !alert.geometry.coordinates) && Array.isArray(properties.affectedZones) && properties.affectedZones.length > 0) {
                    properties.affectedZones.forEach(zoneUrl => {
                        affectedZoneProps.push({style: style, properties: properties});
                        affectedZoneGeometriesPromises.push(fetchZoneGeometry(zoneUrl));
                    });
                }
                let mentionCity = false;
                let cityName = null;
                if (properties.areaDesc && /city/i.test(properties.areaDesc)) {
                    const match = properties.areaDesc.match(/([A-Za-z ]+ City)/i);
                    if (match) {
                        mentionCity = true;
                        cityName = match[1];
                    }
                }
                if (!mentionCity && properties.headline && /city/i.test(properties.headline)) {
                    const match2 = properties.headline.match(/([A-Za-z ]+ City)/i);
                    if (match2) {
                        mentionCity = true;
                        cityName = match2[1];
                    }
                }
                if (mentionCity && cityName) {
                    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(cityName)}&countrycodes=us&limit=1`)
                        .then(response => response.json())
                        .then(data => {
                            if (data && data.length > 0) {
                                cityPoints.push({
                                    lat: parseFloat(data[0].lat),
                                    lng: parseFloat(data[0].lon),
                                    properties: properties
                                });
                                addCityPointsLayer(cityPoints);
                            }
                        });
                }
                if (properties.geocode && properties.geocode.UGC && countyLookup) {
                    properties.geocode.UGC.forEach(ugcCode => {
                        if (ugcCode.length === 6) {
                            const stateCode = ugcCode.substring(0, 2);
                            const countyCode = ugcCode.substring(2);
                            const fipsCode = stateCode + countyCode;
                            if (!countyAlertsByFIPS[fipsCode]) countyAlertsByFIPS[fipsCode] = [];
                            countyAlertsByFIPS[fipsCode].push({
                                alert,
                                style
                            });
                        }
                    });
                }
                if (properties.geocode && properties.geocode.FIPS && countyLookup) {
                    properties.geocode.FIPS.forEach(fipsCode => {
                        if (!countyAlertsByFIPS[fipsCode]) countyAlertsByFIPS[fipsCode] = [];
                        countyAlertsByFIPS[fipsCode].push({
                            alert,
                            style
                        });
                    });
                }
            });

            if (alertGeometries.length > 0) {
                alertPolygonLayer = L.layerGroup();
                alertGeometries.forEach(item => {
                    let layer;
                    if (item.geometry.type === "Polygon") {
                        const coordinates = item.geometry.coordinates[0];
                        const latLngs = coordinates.map(coord => [coord[1], coord[0]]);
                        layer = L.polygon(latLngs, item.style)
                            .bindPopup(createCountyPopupContent(item.properties))
                            .on("mouseover", function(e) {
                                showSimpleInfoPanel(item.properties, e.latlng);
                            })
                            .on("mouseout", function() {
                                hideInfoPanel();
                            });
                    } else if (item.geometry.type === "MultiPolygon") {
                        const polygons = item.geometry.coordinates.map(polygonCoords => {
                            const latLngs = polygonCoords[0].map(coord => [coord[1], coord[0]]);
                            return L.polygon(latLngs, item.style)
                                .on("mouseover", function(e) {
                                    showSimpleInfoPanel(item.properties, e.latlng);
                                })
                                .on("mouseout", function() {
                                    hideInfoPanel();
                                });
                        });
                        layer = L.featureGroup(polygons).bindPopup(createCountyPopupContent(item.properties));
                    }
                    if (layer) { alertPolygonLayer.addLayer(layer); }
                });
                alertPolygonLayer.addTo(map);
            }

            if (affectedZoneGeometriesPromises.length > 0) {
                Promise.all(affectedZoneGeometriesPromises).then(geoms => {
                    affectedZoneLayer = L.layerGroup();
                    geoms.forEach((geometry, i) => {
                        if (!geometry) return;
                        const style = affectedZoneProps[i].style;
                        const properties = affectedZoneProps[i].properties;
                        let layer = null;
                        if (geometry.type === "Polygon") {
                            const coordinates = geometry.coordinates[0];
                            const latLngs = coordinates.map(coord => [coord[1], coord[0]]);
                            layer = L.polygon(latLngs, style).bindPopup(createCountyPopupContent(properties))
                                .on("mouseover", function(e) {
                                    showSimpleInfoPanel(properties, e.latlng);
                                })
                                .on("mouseout", function() {
                                    hideInfoPanel();
                                });
                        } else if (geometry.type === "MultiPolygon") {
                            const polygons = geometry.coordinates.map(polygonCoords => {
                                const latLngs = polygonCoords[0].map(coord => [coord[1], coord[0]]);
                                return L.polygon(latLngs, style)
                                    .on("mouseover", function(e) {
                                        showSimpleInfoPanel(properties, e.latlng);
                                    })
                                    .on("mouseout", function() {
                                        hideInfoPanel();
                                    });
                            });
                            layer = L.featureGroup(polygons).bindPopup(createCountyPopupContent(properties));
                        }
                        if (layer) { affectedZoneLayer.addLayer(layer); }
                    });
                    affectedZoneLayer.addTo(map);
                });
            }

            const countyAlertFeatures = [];
            for (const fips in countyAlertsByFIPS) {
                const base = countyLookup[fips];
                if (base) {
                    let highestSeverityIdx = 99;
                    let mostSevereAlertObj = null;
                    for (const alertObj of countyAlertsByFIPS[fips]) {
                        const sRank = alertObj.style.severityRank !== undefined ? alertObj.style.severityRank : 99;
                        if (sRank < highestSeverityIdx) {
                            highestSeverityIdx = sRank;
                            mostSevereAlertObj = alertObj;
                        }
                    }
                    if (mostSevereAlertObj) {
                        const feature = JSON.parse(JSON.stringify(base));
                        feature.properties = feature.properties || {};
                        feature.properties._alert = mostSevereAlertObj.alert;
                        feature.properties._alertStyle = mostSevereAlertObj.style;
                        countyAlertFeatures.push(feature);
                    }
                }
            }
            if (countyAlertFeatures.length > 0) {
                countyActiveLayer = L.geoJSON(
                    { type: "FeatureCollection", features: countyAlertFeatures },
                    {
                        style: function(f) {
                            const s = f.properties._alertStyle || {};
                            return {
                                color: "#222",
                                weight: 2,
                                fillColor: s.color || "#fff",
                                fillOpacity: (s.fillOpacity !== undefined ? s.fillOpacity : 0.7),
                                className: "active-county " + (s.className || ""),
                                dashArray: s.dashArray || null
                            };
                        },
                        onEachFeature: function(feature, layer) {
                            if (feature.properties && feature.properties._alert) {
                                layer.bindPopup(createCountyPopupContent(feature.properties._alert.properties));
                                layer.on("mouseover", function(e) {
                                    showSimpleInfoPanel(feature.properties._alert.properties, e.latlng);
                                });
                                layer.on("mouseout", function() {
                                    hideInfoPanel();
                                });
                                addLayerEventListeners(layer, feature.properties._alert.properties);
                            }
                        }
                    }
                ).addTo(map);
            }

            addCityPointsLayer(cityPoints);

            if (marineZonesFeatureCollection && marineZonesFeatureCollection.features.length > 0) {
                marineZonesLayer = L.geoJSON(marineZonesFeatureCollection, {
                    style: {
                        color: "#11b6e8",
                        weight: 1,
                        fillColor: "#b6f1ff",
                        fillOpacity: 0.09,
                        opacity: 0.4,
                        className: "marine-zone-outline"
                    }
                }).addTo(map);
            }
            if (cwaFeatureCollection && cwaFeatureCollection.features.length > 0) {
                cwaLayer = L.geoJSON(cwaFeatureCollection, {
                    style: {
                        color: "#000",
                        weight: 1,
                        fillColor: "#fff",
                        fillOpacity: 0,
                        opacity: 0.13,
                        className: "cwa-outline"
                    }
                }).addTo(map);
            }
        }

        function addCityPointsLayer(cityPoints) {
            if (cityPointsLayer) {
                cityPointsLayer.clearLayers();
                map.removeLayer(cityPointsLayer);
                cityPointsLayer = null;
            }
            if (!cityPoints || cityPoints.length === 0) return;
            cityPointsLayer = L.layerGroup();
            cityPoints.forEach(pt => {
                let circle = L.circleMarker([pt.lat, pt.lng], {
                    radius: 6,
                    color: "#444",
                    fillColor: "#ffb700",
                    fillOpacity: 0.95,
                    weight: 2
                });
                if (pt.properties) {
                    circle.bindPopup(createCountyPopupContent(pt.properties));
                    circle.on("mouseover", function(e) {
                        showSimpleInfoPanel(pt.properties, e.latlng);
                    });
                    circle.on("mouseout", function() {
                        hideInfoPanel();
                    });
                    addLayerEventListeners(circle, pt.properties);
                }
                cityPointsLayer.addLayer(circle);
            });
            cityPointsLayer.addTo(map);
        }

        function addLayerEventListeners(layer, properties) {
            layer.on("mouseover", function(e) {
                showSimpleInfoPanel(properties, e.latlng);
            });
            layer.on("mouseout", function() {
                hideInfoPanel();
            });
        }

        function updateFiltersAndLegend() {
            const filtersContainer = document.getElementById("alert-filters");
            const legendContainer = document.getElementById("legend-items");
            filtersContainer.innerHTML = "";
            legendContainer.innerHTML = "";

            let allImportantTypes = {};
            IMPORTANT_ALERT_TYPES.forEach(type => allImportantTypes[type] = true);
            let allTypes = Object.assign({}, alertTypes, allImportantTypes);

            Object.keys(allTypes).sort().forEach(alertType => {
                const style = getAlertStyle({ event: alertType });
                const filterDiv = document.createElement("div");
                filterDiv.className = "filter-checkbox";
                filterDiv.innerHTML = `
                    <input type="checkbox" id="filter-${alertType.replace(/\s+/g, "-")}" 
                           checked onchange="toggleAlertType('${alertType}')">
                    <label for="filter-${alertType.replace(/\s+/g, "-")}">${alertType}</label>
                `;
                filtersContainer.appendChild(filterDiv);
                const legendItem = document.createElement("div");
                legendItem.className = "legend-item";
                legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${style.color}; 
                         ${style.dashArray ? `border: 2px dashed ${style.color};` : ""}"></div>
                    <span>${alertType}</span>
                `;
                legendContainer.appendChild(legendItem);
            });
        }

        window.toggleAlertType = function(alertType) {
            renderAlerts();
        }

        function showSimpleInfoPanel(properties, latlng) {
            const infoPanel = document.getElementById("info-panel");
            infoPanel.innerHTML = `
                <h3>${properties.event || ""}</h3>
                <p><strong>Start:</strong> ${properties.effective ? new Date(properties.effective).toLocaleString() : "-"}</p>
                <p><strong>End:</strong> ${properties.expires ? new Date(properties.expires).toLocaleString() : "-"}</p>
                <p><strong>Severity:</strong> ${properties.severity || "-"}</p>
                <p><strong>Confidence:</strong> ${properties.certainty || "-"}</p>
            `;
            const point = map.latLngToContainerPoint(latlng);
            infoPanel.style.left = (point.x + 10) + "px";
            infoPanel.style.top = (point.y + 10) + "px";
            infoPanel.style.display = "block";
        }

        function showInfoPanel(properties, latlng) {
            showSimpleInfoPanel(properties, latlng);
        }

        function hideInfoPanel() {
            document.getElementById("info-panel").style.display = "none";
        }

        

        function checkUserInAlertArea() {
            if (!userLocation || typeof userLocation.lat !== "number" || typeof userLocation.lng !== "number") {
                return;
            }
            
            const banner = document.getElementById("alert-banner");
            userAlerts = [];
            const userLatLng = L.latLng(userLocation.lat, userLocation.lng);
            
            // Check polygon alerts
            for (const id in alertLayers) {
                const layer = alertLayers[id];
                if (layer) {
                    try {
                        // For polygon layers
                        if (layer instanceof L.Polygon) {
                            if (isPointInPolygon(userLatLng, layer.getLatLngs())) {
                                const properties = getAlertPropertiesFromLayer(layer);
                                if (properties) {
                                    userAlerts.push({
                                        id: id,
                                        eventType: properties.event || "Unknown Alert",
                                        severity: properties.severity || "Unknown"
                                    });
                                }
                            }
                        }
                        // For feature groups (multi-polygon alerts)
                        else if (layer instanceof L.FeatureGroup) {
                            let inAlertArea = false;
                            let alertProperties = null;
                            
                            layer.eachLayer(function(polygonLayer) {
                                if (polygonLayer instanceof L.Polygon && 
                                    isPointInPolygon(userLatLng, polygonLayer.getLatLngs())) {
                                    inAlertArea = true;
                                    alertProperties = getAlertPropertiesFromLayer(polygonLayer);
                                }
                            });
                            
                            if (inAlertArea && alertProperties) {
                                userAlerts.push({
                                    id: id,
                                    eventType: alertProperties.event || "Unknown Alert",
                                    severity: alertProperties.severity || "Unknown"
                                });
                            }
                        }
                    } catch (error) {
                        console.error("Error checking polygon alert:", error);
                    }
                }
            }
            
            // Check county alerts - FIXED VERSION
            if (countyActiveLayer) {
                countyActiveLayer.eachLayer(function(layer) {
                    try {
                        // Get the GeoJSON feature
                        const feature = layer.feature;
                        if (feature && feature.properties && feature.properties._alert) {
                            const alertProperties = feature.properties._alert.properties;
                            
                            // Check if point is within the actual county geometry (not just bounds)
                            if (isPointInCountyFeature(userLatLng, feature)) {
                                userAlerts.push({
                                    id: feature.properties._alert.id || layer._leaflet_id,
                                    eventType: alertProperties.event || "Unknown Alert",
                                    severity: alertProperties.severity || "Unknown",
                                    isCountyAlert: true,
                                    layer: layer,
                                    feature: feature
                                });
                            }
                        }
                    } catch (error) {
                        console.error("Error checking county alert:", error);
                    }
                });
            }
            
            if (userAlerts.length > 0) {
                // Sort alerts by severity
                userAlerts.sort((a, b) => {
                    const severityOrder = { 
                        "Extreme": 0, "Severe": 1, "Moderate": 2, "Minor": 3, "Unknown": 4 
                    };
                    return (severityOrder[a.severity] || 4) - (severityOrder[b.severity] || 4);
                });
                
                currentBannerAlertIndex = 0;
                updateBannerAlert();
                
                if (userAlerts.length > 1) {
                    // Add navigation controls if multiple alerts
                    banner.innerHTML += `
                        <span class="banner-alert-selector" onclick="cycleBannerAlert(-1)">‚óÄ Previous</span>
                        <span class="banner-alert-selector" onclick="cycleBannerAlert(1)">Next ‚ñ∂</span>
                    `;
                }
                
                banner.classList.add("active");
            } else {
                banner.classList.remove("active");
            }
        }
        // Helper function to check if a point is inside a GeoJSON feature
        function isPointInGeoJSONFeature(point, feature) {
            if (!feature || !feature.geometry) return false;
            
            // Convert Leaflet LatLng to GeoJSON format [lng, lat]
            const geoJSONPoint = {
                type: "Point",
                coordinates: [point.lng, point.lat]
            };
            
            // For Polygon features
            if (feature.geometry.type === "Polygon") {
                return pointInPolygonGeoJSON(geoJSONPoint, feature.geometry);
            }
            // For MultiPolygon features
            else if (feature.geometry.type === "MultiPolygon") {
                for (const polygon of feature.geometry.coordinates) {
                    const polyGeoJSON = {
                        type: "Polygon",
                        coordinates: polygon
                    };
                    if (pointInPolygonGeoJSON(geoJSONPoint, polyGeoJSON)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        // NEW FUNCTION: Check if a point is inside a county feature
        function isPointInCountyFeature(point, feature) {
            if (!feature || !feature.geometry) return false;
            
            // Convert Leaflet LatLng to GeoJSON format [lng, lat]
            const geoJSONPoint = {
                type: "Point",
                coordinates: [point.lng, point.lat]
            };
            
            // For Polygon features
            if (feature.geometry.type === "Polygon") {
                return isPointInPolygonGeoJSON(geoJSONPoint, feature.geometry);
            }
            // For MultiPolygon features
            else if (feature.geometry.type === "MultiPolygon") {
                for (const polygon of feature.geometry.coordinates) {
                    const polyGeoJSON = {
                        type: "Polygon",
                        coordinates: polygon
                    };
                    if (isPointInPolygonGeoJSON(geoJSONPoint, polyGeoJSON)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        
        // UPDATED - Ray casting algorithm for point in polygon detection with GeoJSON format
        function isPointInPolygonGeoJSON(point, polygon) {
            const x = point.coordinates[0];
            const y = point.coordinates[1];
            let inside = false;
            
            // Check each polygon ring (first is outer ring, others are holes)
            for (let i = 0; i < polygon.coordinates.length; i++) {
                const ring = polygon.coordinates[i];
                for (let j = 0, k = ring.length - 1; j < ring.length; k = j++) {
                    const xi = ring[j][0], yi = ring[j][1];
                    const xj = ring[k][0], yj = ring[k][1];
                    
                    const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    
                    if (intersect) inside = !inside;
                }
                
                // If we're in a hole, we're not inside the polygon
                if (i > 0 && inside) {
                    return false;
                }
            }
            
            return inside;
        }
        // Helper function to check if a point is inside a Leaflet polygon
        function isPointInPolygon(point, polygon) {
            if (!polygon || polygon.length === 0) return false;
            
            // For simple polygons
            if (polygon[0] instanceof L.LatLng) {
                const polyPoints = polygon.map(latLng => [latLng.lat, latLng.lng]);
                return pointInPolygon([point.lat, point.lng], polyPoints);
            }
            // For multi-polygons or complex shapes
            else if (Array.isArray(polygon[0])) {
                for (const poly of polygon) {
                    if (poly[0] instanceof L.LatLng) {
                        const polyPoints = poly.map(latLng => [latLng.lat, latLng.lng]);
                        if (pointInPolygon([point.lat, point.lng], polyPoints)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Ray casting algorithm for point in polygon detection
        function pointInPolygon(point, vs) {
            const x = point[0], y = point[1];
            let inside = false;
            
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                const xi = vs[i][0], yi = vs[i][1];
                const xj = vs[j][0], yj = vs[j][1];
                
                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                
                if (intersect) inside = !inside;
            }
            
            return inside;
        }
        
        // Helper function to extract alert properties from a layer
        function getAlertPropertiesFromLayer(layer) {
            try {
                const popupContent = layer.getPopup().getContent();
                const parser = new DOMParser();
                const doc = parser.parseFromString(popupContent, "text/html");
                
                const eventType = doc.querySelector("h3") ? doc.querySelector("h3").textContent : "Unknown Alert";
                let severity = "Unknown";
                
                // Try different ways to find severity in the popup content
                const severityElements = doc.querySelectorAll("p");
                for (const element of severityElements) {
                    if (element.textContent.includes("Severity:")) {
                        severity = element.textContent.replace("Severity:", "").trim();
                        break;
                    }
                }
                
                return { event: eventType, severity: severity };
            } catch (error) {
                console.error("Error extracting properties from layer:", error);
                return null;
            }
        }
        
        function updateBannerAlert() {
            const banner = document.getElementById("alert-banner");
            if (userAlerts.length === 0) return;
            
            const alert = userAlerts[currentBannerAlertIndex];
            banner.innerHTML = `
                <strong>${alert.eventType}</strong> is in effect for your location. 
                <a href="#" onclick="focusOnAlert('${alert.id}', ${alert.isCountyAlert || false})">View details</a>
            `;
            
            if (userAlerts.length > 1) {
                banner.innerHTML += `
                    <span class="banner-alert-selector" onclick="cycleBannerAlert(-1)">‚óÄ Previous</span>
                    <span class="banner-alert-selector" onclick="cycleBannerAlert(1)">Next ‚ñ∂</span>
                    <span>(${currentBannerAlertIndex + 1}/${userAlerts.length})</span>
                `;
            }
        }
        
        window.cycleBannerAlert = function(direction) {
            currentBannerAlertIndex += direction;
            if (currentBannerAlertIndex < 0) {
                currentBannerAlertIndex = userAlerts.length - 1;
            } else if (currentBannerAlertIndex >= userAlerts.length) {
                currentBannerAlertIndex = 0;
            }
            updateBannerAlert();
        }
        
        window.focusOnAlert = function(alertId, isCountyAlert = false) {
            // Try to find the alert in polygon layers
            const layer = alertLayers[alertId];
            if (layer) {
                if (layer.getBounds) map.fitBounds(layer.getBounds().pad(0.1));
                layer.openPopup();
                return;
            }
            
            // Try to find the alert in county layers
            if (countyActiveLayer) {
                countyActiveLayer.eachLayer(function(layer) {
                    // Check by layer ID
                    if (layer._leaflet_id == alertId) {
                        map.fitBounds(layer.getBounds().pad(0.1));
                        layer.openPopup();
                        return;
                    }
                    
                    // Check by feature alert ID
                    const feature = layer.feature;
                    if (feature && feature.properties && feature.properties._alert && 
                        feature.properties._alert.id === alertId) {
                        map.fitBounds(layer.getBounds().pad(0.1));
                        layer.openPopup();
                        return;
                    }
                });
            }
            
            // If we still haven't found it, check in userAlerts array
            const userAlert = userAlerts.find(alert => alert.id === alertId);
            if (userAlert && userAlert.layer) {
                map.fitBounds(userAlert.layer.getBounds().pad(0.1));
                userAlert.layer.openPopup();
            }
        }
        
        // ... (the rest of your existing code remains the same)
        const style = document.createElement("style");
        style.textContent = `
            .pulsing-layer {
                animation: pulse-animation 2s infinite;
            }
            @keyframes pulse-animation {
                0% { opacity: 0.7; }
                50% { opacity: 0.3; }
                100% { opacity: 0.7; }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
